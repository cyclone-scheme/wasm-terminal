# Introduction

This file documents the high-level architecture for `wasm-terminal` a web based Read-Eval-Print-Loop (REPL) for Cyclone Scheme.

# Technology

This project uses Web Assembly, SharedArrayBuffer, jQuery, jQuery Terminal, prism.js, and Cyclone Scheme.

# Files

* `_site`
  * `_headers` - Directs our web host, Netlify, to serve the proper HTTP headers required for Web Assembly. Unfortunately this is required to support multithreaded web assembly programs.
  * `index.html` - Redirect to `terminal.html`
  * `terminal.html` - A customized version of the HTML file generated by emscripten. The bulk of the front-end code lives here.
  * `terminal.js` and `terminal.worker.js` - Supporting JavaScript files generated by emscripten.
  * `terminal.wasm` - Compiled version of all of our native code. This includes the compiled Scheme code as well as the Cyclone runtime and supporting libraries.
  * `jquery` `js` - jQuery library
  * `jquery.terminal` `js` and `css` files - Web-based terminal.
  * `prism.js` and friends - JavaScript used for syntax highlighting.
* `src`
  * `terminal.h` - Custom C code that could not be added directly to `terminal.scm` due to compiler limitations.
  * `terminal.c` - A compiled version of `terminal.scm`. This file is not customized so it does not necessarily need to live in source control, but it is useful to have so that we do not need to use the native Cyclone compiler to build the `.wasm` file
  * `terminal.scm` - Code for the Scheme REPL.

# Build Environment

A natively-compiled copy of Cyclone Scheme must be used to compile `terminal.scm`.

`terminal.c` must be compiled by EmScripten. It must also be linked with the Cyclone Scheme libraries built using EmScripten in order to create `terminal.wasm`.

A web hook is in place to update the project on Netlify as changes are pushed to GitHub. Netlify is used because Web Assembly SharedArrayBuffer, which is required for pthreads, will not work unless specific security headers are used to serve our content.

# Data Flow

## Eval

* Terminal is unlocked and receives input string from the user.
* JavaScript passes the string to Scheme (WASM) via `sendToEval.
* Terminal is locked. No more input is allowed during this time.
* Scheme main loop picks up string via `get-input`, and:
  * Parses into a Scheme object by reading from a string port.
  * Passes the object to `eval`. During this process any data written to `stdout` is redirected back to the JavaScript terminal via hooks.
  * After Scheme is done, `ready-for-more-input` is called to unlock the terminal.
  * Loop sleeps until more input is ready.


